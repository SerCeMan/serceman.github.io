<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>The matter of time() - Sergey Tselovalnikov</title><meta content="Empty" name="description"/><meta property="og:url" content="https://serce.me/posts/16-05-2019-the-matter-of-time"/><link rel="canonical" href="https://serce.me/posts/16-05-2019-the-matter-of-time"/><meta property="og:type" content="article"/><meta property="og:site_name" content="The matter of time() - Sergey Tselovalnikov"/><meta property="og:description" content="Empty"/><meta property="og:title" content="The matter of time() - Sergey Tselovalnikov"/><meta property="og:image" content="https://serce.meundefined"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@SerCeMan"/><meta name="twitter:title" content="The matter of time() - Sergey Tselovalnikov"/><meta name="twitter:description" content="Empty"/><meta name="twitter:image" content="https://serce.meundefined"/><meta property="article:published_time" content="2019-05-16"/><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/17ef91645a16c614.css" as="style"/><link rel="stylesheet" href="/_next/static/css/17ef91645a16c614.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8aea71f50af9d276.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8aea71f50af9d276.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-70187573dbb2adba.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d9bd6946354a189.js" defer=""></script><script src="/_next/static/chunks/105-7a67388502189cf8.js" defer=""></script><script src="/_next/static/chunks/675-25da51e9f406e7b5.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-a7d1e1bbffbcf525.js" defer=""></script><script src="/_next/static/mbWVr8AwAz6q39oslIoEa/_buildManifest.js" defer=""></script><script src="/_next/static/mbWVr8AwAz6q39oslIoEa/_ssgManifest.js" defer=""></script></head><body style="background-color:#f2f2f2" class="bg-white text-gray-900"><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if(e){c.add(e|| '')}else{c.add('light');}if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'light'}catch(t){}}();</script><header style="background-color:#f8f8f8" class="relative shadow-md"><div class="max-w-5xl px-8 py-1 mx-auto"><div class="flex items-center justify-between"><nav class="flex flow-row justify-between items-center w-full text-lg"><a style="font-family:Alegreya" class="text-gray-500 pr-6 py-4 float-left w-1/2 text-4xl" href="/">SerCe&#x27;s blog</a><div class="float-right"><div class="grid grid-cols-3 gap-12"><a class="text-gray-600 py-4" href="/">Home</a><a class="text-gray-600 py-4" href="/blog">Blog</a><a class="text-gray-600 py-4" href="/talks">Talks</a></div></div></nav></div></div></header><main><div><article class="container mx-auto mt-12 px-10 py-8 shadow-md bg-white max-w-5xl flex flex-col"><p class="self-start text-sm text-gray-500">16 May 2019</p><div class="asciiprose"><h1 class="text-gray-900">The matter of time()</h1><p>Hi!</p>
<p>As software engineers, we all rely on the notion of time: a crucial
concept in ensuring that events in our programs follow a chronological
order. Yet, invoking a simple call to ‚Äúget the current time‚Äù can
potentially yield unexpected results and lead to unforeseen consequences
if not used correctly. Moreover, the invariants about time we observe on
our local development machine may not necessarily hold in the cloud, or
in any distributed system.</p>
<p>In this article, I‚Äôll go through the different ways we can obtain the
current time in our programs, and present cases where our intuitions and
expectations of time from these clocks may mislead us at best or cause
catastrophic failures at worst.</p>
<p><img src="/images/time/time_1.png" alt=""/></p>
<div class="quoteblock"><blockquote><div class="paragraph"><p>What would be the biological reality of planet earth rotating once every
eighteen hours instead of twenty-four? You have less time, but you have more days
in the year. So there‚Äôs a sense of losing something, and also gaining something.
With an 18-hour clock there‚Äôs a lot more yesterdays.</p></div></blockquote><div class="attribution">‚Äî <!-- -->Untitled (Clock) 2014</div></div>
<table><thead><tr><th>‚ö†Ô∏è</th><th>This article is illustrated with examples of code in Java. However, most of the content of this article is applicable to any language or runtime.</th></tr></thead></table>
<h2 id="your-local-clocks"><a class="anchor" href="#your-local-clocks"><span class="icon icon-link"></span></a>Your local clocks</h2>
<p>Let me start by asking you six questions. Here is a set of code
snippets. Is it possible that the expression passed to <code>isThisPossible</code>
is true? Take a guess.</p>
<div class="formalpara-title"><p><span id="aq1"></span>1. Is this possible?</p></div>
<pre><code class="hljs language-java"><span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
<span class="hljs-type">long</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> System.currentTimeMillis();

isThisPossible(t2 - t1 == <span class="hljs-number">0</span>);
</code></pre>
<div class="btn-group btn-group-toggle btn-group-justified text-slate-100" data-toggle="buttons"><div class="flex justify-between"><label class="bg-green-500 w-6/12 rounded-full p-2"><input type="radio" name="q1" id="yes" autoComplete="off" value="yes"/>Yes</label><label class="bg-red-500 w-6/12 rounded-full p-2"><input type="radio" name="q1" id="no" autoComplete="off" value="no"/>No</label></div></div>
<div class="formalpara-title"><p><span id="aq2"></span>2. Is this possible?</p></div>
<pre><code class="hljs language-java"><span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();
<span class="hljs-type">long</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> System.nanoTime();

isThisPossible(t2 - t1 == <span class="hljs-number">0</span>);
</code></pre>
<div class="btn-group btn-group-toggle btn-group-justified text-slate-100" data-toggle="buttons"><div class="flex justify-between"><label class="bg-green-500 w-6/12 rounded-full p-2"><input type="radio" name="q2" id="yes" autoComplete="off" value="yes"/>Yes</label><label class="bg-red-500 w-6/12 rounded-full p-2"><input type="radio" name="q2" id="no" autoComplete="off" value="no"/>No</label></div></div>
<div class="formalpara-title"><p><span id="aq3"></span>3. Is this possible?</p></div>
<pre><code class="hljs language-java"><span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
<span class="hljs-type">long</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> System.currentTimeMillis();

isThisPossible(t2 &lt; t1);
</code></pre>
<div class="btn-group btn-group-toggle btn-group-justified text-slate-100" data-toggle="buttons"><div class="flex justify-between"><label class="bg-green-500 w-6/12 rounded-full p-2"><input type="radio" name="q3" id="yes" autoComplete="off" value="yes"/>Yes</label><label class="bg-red-500 w-6/12 rounded-full p-2"><input type="radio" name="q3" id="no" autoComplete="off" value="no"/>No</label></div></div>
<div class="formalpara-title"><p><span id="aq4"></span>4. Is this possible?</p></div>
<pre><code class="hljs language-java"><span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();
<span class="hljs-type">long</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> System.nanoTime();

isThisPossible(t2 &lt; t1);
</code></pre>
<div class="btn-group btn-group-toggle btn-group-justified text-slate-100" data-toggle="buttons"><div class="flex justify-between"><label class="bg-green-500 w-6/12 rounded-full p-2"><input type="radio" name="q4" id="yes" autoComplete="off" value="yes"/>Yes</label><label class="bg-red-500 w-6/12 rounded-full p-2"><input type="radio" name="q4" id="no" autoComplete="off" value="no"/>No</label></div></div>
<div class="formalpara-title"><p><span id="aq5"></span>5. Is this possible?</p></div>
<pre><code class="hljs language-java"><span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.currentTimeMillis();

isThisPossible(t1 &lt; <span class="hljs-number">0</span>);
</code></pre>
<div class="btn-group btn-group-toggle btn-group-justified text-slate-100" data-toggle="buttons"><div class="flex justify-between"><label class="bg-green-500 w-6/12 rounded-full p-2"><input type="radio" name="q5" id="yes" autoComplete="off" value="yes"/>Yes</label><label class="bg-red-500 w-6/12 rounded-full p-2"><input type="radio" name="q5" id="no" autoComplete="off" value="no"/>No</label></div></div>
<div class="formalpara-title"><p><span id="aq6"></span>6. Is this possible?</p></div>
<pre><code class="hljs language-java"><span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();

isThisPossible(t1 &lt; <span class="hljs-number">0</span>);
</code></pre>
<div class="btn-group btn-group-toggle btn-group-justified text-slate-100" data-toggle="buttons"><div class="flex justify-between"><label class="bg-green-500 w-6/12 rounded-full p-2"><input type="radio" name="q6" id="yes" autoComplete="off" value="yes"/>Yes</label><label class="bg-red-500 w-6/12 rounded-full p-2"><input type="radio" name="q6" id="no" autoComplete="off" value="no"/>No</label></div></div>
<div style="margin-top:1.25em"><button id="checkquizres" class="bg-blue-500 w-full text-white rounded-full p-2 hover:bg-blue-600 focus:bg-blue-600 focus:outline-none" type="button" data-toggle="collapse" data-target="#collapseExample" aria-expanded="false" aria-controls="collapseExample">Check results</button><div class="collapse" id="collapseExample"><div id="showquizres" class="well"><p id="sqr1"></p><p id="sqr2"></p><p id="sqr3"></p><p id="sqr4"></p><p id="sqr5"></p><p id="sqr6"></p></div></div></div>
<p>Was the result surprising? My sincere kudos if it was not. The next
section of the article will explain why certain behaviour can or can not
be observed.</p>
<p>But why do we even care? Very often we don‚Äôt need to, but the snippets
of code where the business logic relies on the observed timestamps are
typically critical pieces of infrastructure code where correctness is a
must. False assumptions in these parts of the code can lead to huge
incidents. This, for instance, happened to <a href="https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/">Cloudflare in
2017</a>,
where the root cause &quot;was the belief that time cannot go backwards&quot;.
Cloudflare is one of the few companies that openly publishes incident
reports, but it‚Äôs not uncommon to suffer from such false assumptions, as
a few Google searches can confirm, and we can all learn from these
mistakes. To understand why certain clocks behave in a certain way, we
first need to understand what properties different clocks can give us.</p>
<h3 id="monotonicity"><a class="anchor" href="#monotonicity"><span class="icon icon-link"></span></a>Monotonicity</h3>
<p>The first property is monotonicity. A monotonically increasing function
means that for every subsequent invocation of such a function the
produced value is never smaller than any of the previous values. So, a
monotonic clock is a clock that never goes backwards. Sadly, and
surprisingly, this property is not a feature of many clocks.</p>
<h3 id="resolution"><a class="anchor" href="#resolution"><span class="icon icon-link"></span></a>Resolution</h3>
<p>Resolution is the second property. It is the smallest observable
difference between two clock ticks. The resolution of a simple
mechanical watch with a second hand is one second. When you‚Äôre staring
at the watch, the meaningful watch hand position can be at 12 seconds or
13 seconds, but never 12 and a half.</p>
<h3 id="latency"><a class="anchor" href="#latency"><span class="icon icon-link"></span></a>Latency</h3>
<p>Very often latency is overlooked when we‚Äôre talking about clocks, but
it‚Äôs quite important when we‚Äôre considering other properties like
resolution. For instance, it doesn‚Äôt matter if you have the most precise
atomic watch on your hand with picosecond resolution ‚Äí if I ask you what
time it is and it takes you roughly a second, sometimes less, sometimes
more, to take a look and respond, all of this precision fades away.</p>
<p>So, what properties do Java clocks have, and how do they apply to the
questions that we looked at the beginning?</p>
<h2 id="clocks-on-the-wall"><a class="anchor" href="#clocks-on-the-wall"><span class="icon icon-link"></span></a>Clocks on the wall</h2>
<p>Let‚Äôs start with <code>System.currentTimeMillis()</code>. Usually, the best place
to start the exploration is the documentation written in the Javadoc,
and there is a lot there to take in. Here is an excerpt of what is
important to us right now.</p>
<div class="formalpara-title"><p><em><a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/java.base/share/classes/java/lang/System.java#l375">Javadoc</a></em></p></div>
<pre><code class="hljs language-java"><span class="hljs-comment">/**
 * Returns the current time in milliseconds. Note that
 * while the unit of time of the return value is a millisecond,
 * the granularity of the value depends on the underlying
 * operating system and may be larger.  For example, many
 * operating systems measure time in units of tens of
 * milliseconds.
 *
 * ...
 *
 * <span class="hljs-doctag">@return</span>  the difference, measured in milliseconds, between
 *          the current time and midnight, January 1, 1970 UTC.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">currentTimeMillis</span><span class="hljs-params">()</span>;
</code></pre>
<p>As we can see, the clock provides us with a millisecond precision value
but the actual resolution depends on the operating system. Moreover, if
we measure the latency by measuring the execution time, it will be way
below 1 millisecond, so it‚Äôs maybe not a surprise that the answer to the
<a href="#aq1">first question</a> was yes.</p>
<p>But can it go backwards? The Javadoc doesn‚Äôt mention anything about
monotonicity, so we need to dig deeper, and take a look at the
implementation.</p>
<table><thead><tr><th>‚ö†Ô∏è</th><th>This article only explores the native implementation for Linux and MacOS. However, similar techniques can be applied to other operating systems as well.</th></tr></thead></table>
<p>The method is native, so the implementation depends on the underlying
OS. The native implementation for Linux and MacOS look almost identical.</p>
<div class="formalpara-title"><p><em><a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/linux/os_linux.cpp#l1204">Linux</a></em></p></div>
<pre><code class="hljs language-cpp"><span class="hljs-function">jlong <span class="hljs-title">os::javaTimeMillis</span><span class="hljs-params">()</span> </span>{
  timeval time;
  <span class="hljs-type">int</span> status = <span class="hljs-built_in">gettimeofday</span>(&amp;time, <span class="hljs-literal">NULL</span>);
  <span class="hljs-built_in">assert</span>(status != <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;linux error&quot;</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">jlong</span>(time.tv_sec) * <span class="hljs-number">1000</span>  +  <span class="hljs-built_in">jlong</span>(time.tv_usec / <span class="hljs-number">1000</span>);
}
</code></pre>
<div class="formalpara-title"><p><em><a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/bsd/os_bsd.cpp#l893">MacOS</a></em></p></div>
<pre><code class="hljs language-cpp"><span class="hljs-function">jlong <span class="hljs-title">os::javaTimeMillis</span><span class="hljs-params">()</span> </span>{
  timeval time;
  <span class="hljs-type">int</span> status = <span class="hljs-built_in">gettimeofday</span>(&amp;time, <span class="hljs-literal">NULL</span>);
  <span class="hljs-built_in">assert</span>(status != <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;bsd error&quot;</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">jlong</span>(time.tv_sec) * <span class="hljs-number">1000</span>  +  <span class="hljs-built_in">jlong</span>(time.tv_usec / <span class="hljs-number">1000</span>);
}
</code></pre>
<p>The functions invoke exactly the same syscall, <code>gettimeofday</code>. The man
page can provide us with more info, but more importantly with some
valuable notes:</p>
<div class="formalpara-title"><p><em><a href="http://man7.org/linux/man-pages/man2/gettimeofday.2.html">man page</a></em></p></div>
<pre><code class="">NAME
       gettimeofday, settimeofday - get / set time

NOTES
       The time returned by gettimeofday() is affected by discontinuous
       jumps in the system time (e.g., if the system administrator manually
       changes the system time).  If you need a monotonically increasing
       clock, see clock_gettime(2).
</code></pre>
<p>As noted above, the time is affected by discontinuous jumps in the
system time, which could be backwards, hence the clock is not monotonic.
The answer to the <a href="#aq3">third question</a> was yes which does make sense:
if we change the current time to one hour ago, we still want
<code>currentTimeMillis</code> to return current time, even though the definition
of the current time has changed. That‚Äôs why it‚Äôs often called wall-clock
time, the clock on the wall can also jump back in time if we adjust it.</p>
<h3 id="the-nanos-of-the-current-time"><a class="anchor" href="#the-nanos-of-the-current-time"><span class="icon icon-link"></span></a>The nanos of the current time</h3>
<p>The same exploration path can be taken for <code>System.nanoTime()</code>. Let‚Äôs
start from the Javadoc which has even more intriguing details than the
previous one; here is an excerpt.</p>
<div class="formalpara-title"><p><em><a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/java.base/share/classes/java/lang/System.java#l394">Javadoc</a></em></p></div>
<pre><code class="hljs language-java"><span class="hljs-comment">/**
 * Returns the current value of the running Java Virtual Machine&#x27;s
 * high-resolution time source, in nanoseconds.
 *
 * This method can only be used to measure elapsed time and is
 * not related to any other notion of system or wall-clock time.
 * The value returned represents nanoseconds since some fixed but
 * arbitrary &lt;i&gt;origin&lt;/i&gt; time (perhaps in the future, so values
 * may be negative) ...
 *
 * &lt;p&gt;This method provides nanosecond precision, but not necessarily
 * nanosecond resolution ...
 *
 * &lt;p&gt;The values returned by this method become meaningful only when
 * the difference between two such values, obtained within the same
 * instance of a Java virtual machine, is computed.
 *
 * ...
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nanoTime</span><span class="hljs-params">()</span>;
</code></pre>
<p>Apparently, the time returned by this clock isn‚Äôt related to any
real-world time; it can only be used to compare the timestamps within
the same JVM instance, and it‚Äôs relative to an arbitrary ‚Äúorigin‚Äù which
can be in the future, and therefore it might be negative ‚Äì which answers
the <a href="#aq3">sixth question</a>. Similar to <code>currentTimeMillis</code>, this method
provides nanosecond precision, but not necessarily nanosecond
resolution.</p>
<p>Nano time can only be used to measure time intervals, so it ought to be
monotonic, right? Unfortunately, the Javadoc doesn‚Äôt say anything about
monotonicity, so the next step is the implementation.</p>
<div class="formalpara-title"><p><em><a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/linux/os_linux.cpp#l1301">Linux</a></em></p></div>
<pre><code class="hljs language-cpp"><span class="hljs-function">jlong <span class="hljs-title">os::javaTimeNanos</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (os::<span class="hljs-built_in">supports_monotonic_clock</span>()) {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> tp;
    <span class="hljs-type">int</span> status = Linux::<span class="hljs-built_in">clock_gettime</span>(CLOCK_MONOTONIC, &amp;tp);
    <span class="hljs-built_in">assert</span>(status == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;gettime error&quot;</span>);
    jlong result = <span class="hljs-built_in">jlong</span>(tp.tv_sec) * (<span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>) + <span class="hljs-built_in">jlong</span>(tp.tv_nsec);
    <span class="hljs-keyword">return</span> result;
  } <span class="hljs-keyword">else</span> {
    timeval time;
    <span class="hljs-type">int</span> status = <span class="hljs-built_in">gettimeofday</span>(&amp;time, <span class="hljs-literal">NULL</span>);
    <span class="hljs-built_in">assert</span>(status != <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;linux error&quot;</span>);
    jlong usecs = <span class="hljs-built_in">jlong</span>(time.tv_sec) * (<span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>) + <span class="hljs-built_in">jlong</span>(time.tv_usec);
    <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span> * usecs;
  }
}
</code></pre>
<p>Here comes the first surprise: nano time is indeed monotonic but
<em>only</em> if the underlying operating system supports it. To be fair, any
modern Linux server supports <code>CLOCK_MONOTONIC</code>; there are, however, some
<a href="https://stackoverflow.com/a/51345008/1542319">rare situations</a> in which
it might not hold true.</p>
<div class="formalpara-title"><p><em><a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/bsd/os_bsd.cpp#l893">MacOS</a></em></p></div>
<pre><code class="hljs language-cpp"><span class="hljs-function">jlong <span class="hljs-title">os::javaTimeNanos</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> tm = <span class="hljs-built_in">mach_absolute_time</span>();
  <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> now = (tm * Bsd::_timebase_info.numer) / Bsd::_timebase_info.denom;
  <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> prev = Bsd::_max_abstime;
  <span class="hljs-keyword">if</span> (now &lt;= prev) {
    <span class="hljs-keyword">return</span> prev;   <span class="hljs-comment">// same or retrograde time;</span>
  }
  <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> obsv = Atomic::<span class="hljs-built_in">cmpxchg</span>(now, &amp;Bsd::_max_abstime, prev);
  <span class="hljs-built_in">assert</span>(obsv &gt;= prev, <span class="hljs-string">&quot;invariant&quot;</span>);   <span class="hljs-comment">// Monotonicity</span>
  <span class="hljs-comment">// If the CAS succeeded then we&#x27;re done and return &quot;now&quot;.</span>
  <span class="hljs-comment">// If the CAS failed and the observed value &quot;obsv&quot; is &gt;= now then</span>
  <span class="hljs-comment">// we should return &quot;obsv&quot;.  If the CAS failed and now &gt; obsv &gt; prv then</span>
  <span class="hljs-comment">// some other thread raced this thread and installed a new value, in which case</span>
  <span class="hljs-comment">// we could either (a) retry the entire operation, (b) retry trying to install now</span>
  <span class="hljs-comment">// or (c) just return obsv.  We use (c).   No loop is required although in some cases</span>
  <span class="hljs-comment">// we might discard a higher &quot;now&quot; value in deference to a slightly lower but freshly</span>
  <span class="hljs-comment">// installed obsv value.   That&#x27;s entirely benign -- it admits no new orderings compared</span>
  <span class="hljs-comment">// to (a) or (b) -- and greatly reduces coherence traffic.</span>
  <span class="hljs-comment">// We might also condition (c) on the magnitude of the delta between obsv and now.</span>
  <span class="hljs-comment">// Avoiding excessive CAS operations to hot RW locations is critical.</span>
  <span class="hljs-comment">// See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate</span>
  <span class="hljs-keyword">return</span> (prev == obsv) ? now : obsv;
}
</code></pre>
<p>The first thing that stands out is the giant wall of comments. As
software engineers, we know that if there is a long comment then
something dodgy must be going on. Indeed, the comment is quite
interesting. The call to
<a href="https://opensource.apple.com/source/Libc/Libc-320.1.3/i386/mach/mach_absolute_time.c.auto.html"><code>mach_absolute_time</code></a>
uses the <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">RDTSC</a>
instruction underneath which can <em>potentially</em> lead to non-monotonic
behaviour on machines with multiple CPU sockets, which recently span up
another thought-provoking discussion on the <a href="https://groups.google.com/forum/#!topic/mechanical-sympathy/7WnH37dA6Yc">mechanical
sympathy</a>
mailing list.</p>
<p>So, at least, we can be confident that nano time is always monotonic on
MacOS, right? Actually, it depends on the JVM version. The code listed
above was introduced in JDK9 in
<a href="https://bugs.openjdk.java.net/browse/JDK-8040140">JDK-8040140</a> and
backported to JDK8. Before, all you could hope for was non-monotonic
time which provided at best microsecond resolution because
<code>gettimeofday</code> was used. If we run some
<a href="https://shipilev.net/blog/2014/nanotrusting-nanotime/#_latency">benchmarks</a>,
we‚Äôll see that the latency for these calls can be as small as 30ns, so
suddenly the answer to the <a href="#aq2">second</a> and the <a href="#aq4">fourth</a>
questions is true, or rather &quot;it depends&quot;.</p>
<h3 id="when-milliseconds-are-not-enough"><a class="anchor" href="#when-milliseconds-are-not-enough"><span class="icon icon-link"></span></a>When milliseconds are not enough</h3>
<p>The microsecond precision in the case of <code>gettimeofday</code> is much more
than <code>System.currentTimeMillis()</code> can give us, but in the process of
conversion precision is lost.</p>
<pre><code class="hljs language-cpp"><span class="hljs-function">jlong <span class="hljs-title">os::javaTimeMillis</span><span class="hljs-params">()</span> </span>{
  timeval time;
  <span class="hljs-type">int</span> status = <span class="hljs-built_in">gettimeofday</span>(&amp;time, <span class="hljs-literal">NULL</span>);
  <span class="hljs-built_in">assert</span>(status != <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;linux error&quot;</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">jlong</span>(time.tv_sec) * <span class="hljs-number">1000</span>  +  <span class="hljs-built_in">jlong</span>(time.tv_usec / <span class="hljs-number">1000</span>);
                                                      <span class="hljs-comment">// ^^ precision loss</span>
}
</code></pre>
<p>The OS can give us additional information which we violently discard in
order to fit it into a single long. What if we really want to know these
micros? In JDK 8, the new JSR 310 arrived which made it possible to
obtain an instance of <code>Instant</code> class which contains the number of
seconds since the epoch and the number of nanoseconds since the last
second started.</p>
<div class="formalpara-title"><p><em><a href="https://jcp.org/en/jsr/detail?id=310">JSR 310: Date and Time API</a></em></p></div>
<pre><code class="hljs language-java"><span class="hljs-type">Instant</span> <span class="hljs-variable">instant</span> <span class="hljs-operator">=</span> Clock.systemUTC().instant();
<span class="hljs-type">long</span> <span class="hljs-variable">epochSecond</span> <span class="hljs-operator">=</span> instant.getEpochSecond();
<span class="hljs-type">int</span> <span class="hljs-variable">nanoSinceSecond</span> <span class="hljs-operator">=</span> instant.getNano();
</code></pre>
<p>Finally, all Java developers got access to wall-clock time with high
precision, right? Not so fast, if we take a look at the implementation
in JDK8, we‚Äôll find out that it simply delegates straight to
<code>System.currentTimeMillis()</code>.</p>
<div class="formalpara-title"><p><em><a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/time/Clock.java#l469">JDK8
Clock</a></em></p></div>
<pre><code class="hljs language-java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">millis</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> System.currentTimeMillis();
}
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Instant <span class="hljs-title function_">instant</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> Instant.ofEpochMilli(millis());
}
</code></pre>
<p>Evidently, this is not optimal and there is a corresponding issue
<a href="https://bugs.openjdk.java.net/browse/JDK-8068730">JDK-8068730</a> which
has already been resolved and as a result, the precision was increased.
It requires an update to JDK9+ where the method delegates to a native
call with the following implementation on Linux. Assuming that your OS
can provide microsecond resolution, this clock is a great example of a
clock with nanosecond precision, but only microsecond resolution.</p>
<div class="formalpara-title"><p><em><a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/linux/os_linux.cpp#l1211">JDK9+
Clock</a></em></p></div>
<pre><code class="hljs language-java"><span class="hljs-keyword">void</span> os::javaTimeSystemUTC(jlong &amp;seconds, jlong &amp;nanos) {
  timeval time;
  <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> gettimeofday(&amp;time, NULL);
  <span class="hljs-keyword">assert</span>(status != -<span class="hljs-number">1</span>, <span class="hljs-string">&quot;linux error&quot;</span>);
  seconds = jlong(time.tv_sec);
  nanos = jlong(time.tv_usec) * <span class="hljs-number">1000</span>;
}
</code></pre>
<h2 id="time-exchange"><a class="anchor" href="#time-exchange"><span class="icon icon-link"></span></a>Time exchange</h2>
<p>The possibility to get the current wall-clock time with microsecond
resolution is great, but is needed often? One of the reasons to use
wall-clock time is to be able to relate an event that happened on one
machine to another event that happened on a different machine, or more
precisely, to decide on the order of these events. The events can be
very different in nature. Some of them might not be very critical, like
the timestamp on a log line, but some of them must be correct, like when
there is a conflict in a database due to two values being written
concurrently and timestamps are used to determine which event was last.
This strategy is called Last Write Wins, or simply LWW.</p>
<div class="canva-embed" data-design-id="DADZmyL_mRw" data-height-ratio="0.5625" style="padding:56.2500% 5px 5px 5px;background:rgba(0,0,0,0.03);border-radius:8px"></div>
<p>On the slides above, two clients Alice and Bob are trying to write
simultaneously into an eventually consistent webscale database with two
nodes. While the first value written by Alice was successfully
synchronized, Alice‚Äôs second write happened to be at approximately the
same time as Bob‚Äôs. In this situation, the database must resolve the
conflict so that the data is consistent between all of the nodes. In the
case of LWW, the latest write will be chosen by comparing the timestamps
of each write. LWW works perfectly if the clocks are perfectly
synchronised, however, if the clocks are poorly synchronised and the
clock of the first node has drifted ahead of the second node, LWW
becomes Lucky Write Wins ‚Äì the client connected to the lucky node always
wins the conflict.</p>
<h3 id="ntp"><a class="anchor" href="#ntp"><span class="icon icon-link"></span></a>NTP</h3>
<p>The standard approach to make sure that the clocks on different nodes in
the cluster are synchronized is to use Network Time Protocol (NTP). Not
only does NTP help synchronise clocks, it also helps propagate a leap
second flag. Leap second is an occasional event where an additional
second is introduced in between 23:59:59 of a chosen day and 00:00:00 of
the following day. It‚Äôs often implemented as playing the same second
twice which from the observer‚Äôs point of view might look like a jump 1
second back in time. The last leap second was introduced on the 31st of
December 2016 which resulted in the above-mentioned DNS incident.</p>
<p><img src="/images/time/time_2.png" alt=""/></p>
<p>The conventional way of dealing with leap seconds is &quot;leap smearing&quot;.
The NTP server which is responsible for leap smearing can distribute the
additional second amongst 12 hours before and 12 hours after the second
is introduced. The wall-clock time during these 24 hours is ticking
slower and every second is 1/86400 longer which might be surprising,
however less surprising than a jump back in time. The catch is that not
many NTP servers support leap smearing, the public NTP servers most
definitely don‚Äôt.</p>
<p>The major cloud providers,
<a href="https://developers.google.com/time/smear">Google</a> and
<a href="https://aws.amazon.com/blogs/aws/look-before-you-leap-the-coming-leap-second-and-aws/">AWS</a>
both provide NTP services with leap smearing support. If your
application is hosted on a platform that provides an NTP service and you
care about clock synchronisation it‚Äôs worthwhile checking that NTP
synchronisation is set up with the provider‚Äôs NTP service. Not only can
it help avoid the nasty consequences of applying leap seconds na√Øvely,
but it also dramatically decreases the synchronisation error since the
network latency is typically much lower within a single datacenter.</p>
<div class="formalpara-title"><p><em>AWS NTP with chrony</em></p></div>
<pre><code class="hljs language-shell">sergey:~$ chronyc sources -v
210 Number of sources = 9

  .-- Source mode  &#x27;^&#x27; = server, &#x27;=&#x27; = peer, &#x27;#&#x27; = local clock.
 / .- Source state &#x27;*&#x27; = current synced, &#x27;+&#x27; = combined , &#x27;-&#x27; = not combined,
| /   &#x27;?&#x27; = unreachable, &#x27;x&#x27; = time may be in error, &#x27;~&#x27; = time too variable.
||                                                 .- xxxx [ yyyy ] +/- zzzz
||      Reachability register (octal) -.           |  xxxx = adjusted offset,
||      Log2(Polling interval) --.      |          |  yyyy = measured offset,
||                                \     |          |  zzzz = estimated error.
||                                 |    |           \
MS Name/IP address         Stratum Poll Reach LastRx Last sample
===============================================================================
^* 169.254.169.123               3  10   377   433    -25us[  -36us] +/-  356us
</code></pre>
<p>Using a local NTP server can reduce the clock drift down to milliseconds
or even microseconds in the best case, but what is the worst case? There
is not much research on this topic, however some notable results were
mentioned in the Google Spanner paper.</p>
<blockquote>
<p>Between synchronizations, a daemon advertises a slowly increasing time
uncertainty. Œµ is derived from conservatively applied worst-case local
clock drift. Œµ also depends on time-master uncertainty and
communication delay to the time masters. In our production
environment, Œµ is typically a sawtooth function of time, varying from
about 1 to 7 ms over each poll interval. ŒµÃÖ is therefore 4 ms most of
the time. The daemon‚Äôs poll interval is currently 30 seconds, and the
current applied drift rate is set at 200 microseconds/second, which
together accounts for the sawtooth bounds from 0 to 6 ms.<br/>
<!-- -->‚Äî  Spanner: Google‚Äôs Globally-Distributed Database</p>
</blockquote>
<h2 id="logical-conclusion"><a class="anchor" href="#logical-conclusion"><span class="icon icon-link"></span></a>Logical conclusion</h2>
<p>Even if the monitoring in our cluster shows that the clocks are
synchronised with microsecond precision, we need to be cautious and
shouldn‚Äôt rely on this in our software if a failure of this assumption
is unacceptable. So, if a failure is unacceptable and we need to know
the order of the events in a distributed system, is there anything we
can do? As always, there is a number of solutions suggested by academia.</p>
<h3 id="lamport-clocks"><a class="anchor" href="#lamport-clocks"><span class="icon icon-link"></span></a>Lamport clocks</h3>
<p>What we need is a reliable replacement for our system clocks, so that
for every two events <em>A</em> and <em>B</em> we can say that either <em>A</em> happened
before <em>B</em>, or <em>B</em> happened before <em>A</em>. Such order between events is
called total order. In the <a href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf">&quot;Time, Clocks, and the Ordering of Events in
a Distributed
System&quot;</a> paper
Leslie Lamport described the &quot;happens before&quot; relation and logical
clocks that can be used to define total order for a set of events using
the following algorithm.</p>
<table><colgroup><col style="width:50%"/><col style="width:50%"/></colgroup><tbody><tr class="odd"><td style="text-align:left"><p>Sending a message</p></td>
<td style="text-align:left"><p>Receiving a message</p></td></tr><tr class="even"><td style="text-align:left"><pre class="pseudocode"><pre><code class="">time = time + 1;
send(message, time);
</code></pre></pre></td><td style="text-align:left"><pre class="pseudocode"><pre><code class="">(message, ts) = receive();
time = max(ts, time) + 1;
</code></pre></pre></td></tr></tbody></table>
<p>Every actor, in this case, Alice and Bob, will maintain a shared view of
the current time by maintaining a <code>time</code> counter which increases every
time a message is sent, and when a message is received, the <code>time</code> is
always bigger than the last observed counter. That way if Alice updates
the Database as shown below with the value 2 and tells Bob about the
last known state, Bob‚Äôs final write carries with it the knowledge of
seeing Alice‚Äôs counter, so it‚Äôs chosen as the final state of the
database.</p>
<table><thead><tr><th>‚ùóÔ∏è</th><th>In the slides below, Alice tells Bob the value she wrote to the first node. Alternatively, Bob could have read the same value from the first node, leading to the same result ‚Äì Alice and Bob don&#x27;t have to communicate directly.</th></tr></thead></table>
<div class="canva-embed" data-design-id="DADZnGWHlAU" data-height-ratio="0.5625" style="padding:56.2500% 5px 5px 5px;background:rgba(0,0,0,0.03);border-radius:8px"></div>
<p>This works perfectly as long as we need to define some total order of
the events in the system which captures the causality. It‚Äôs important to
note that having total order means that concurrent events will be
ordered in some way, not necessarily the most logical way. On the slides
below, Alice never talked to Bob, but her counter is bigger which leads
to her write being chosen in the case of a conflict.</p>
<div class="canva-embed" data-design-id="DADZnC8PNnM" data-height-ratio="0.5625" style="padding:56.2500% 5px 5px 5px;background:rgba(0,0,0,0.03);border-radius:8px"></div>
<h3 id="vector-clocks"><a class="anchor" href="#vector-clocks"><span class="icon icon-link"></span></a>Vector clocks</h3>
<p>To deal with truly concurrent events, we need a new definition or order
which is able to express the situation in which events can happen
concurrently. Such order is called partial order. Basically, this means
that for any two events <em>A</em> and <em>B</em>, it‚Äôs possible to say whether <em>A</em>
happened before <em>B</em>, <em>B</em> happened before <em>A</em> or <em>A</em> and <em>B</em> happened
concurrently. To determine partial order the following algorithm can be
used this, where every actor has a separate time counter, and keeps
track of the latest timestamp of any other actor in the system.</p>
<table><colgroup><col style="width:50%"/><col style="width:50%"/></colgroup><tbody><tr class="odd"><td style="text-align:left"><p>Sending a message</p></td>
<td style="text-align:left"><p>Receiving a message</p></td></tr><tr class="even"><td style="text-align:left"><pre class="pseudocode"><pre><code class="">V[myId] = V[myId] + 1
send(message, V);
</code></pre></pre></td><td style="text-align:left"><pre class="pseudocode"><pre><code class="">(message, Vr) = receive();
for (i, v) in Vr {
    V[i] = max(V[i], v);
}
V[myId] = V[myId] + 1;
</code></pre></pre></td></tr></tbody></table>
<p>The algorithm was described in 1988, and later using vector clocks for
conflict resolution in a database was described in the Dynamo paper. On
the following slides, Alice keeps track of her own time counter as well
as Bob‚Äôs last known time counter. That way when Alice sends a message to
Bob, he updates his counters and the next message sent to the database
is chosen during the conflict resolution because each component of Bob‚Äôs
time vector is larger than the respective component of the previous
vector.</p>
<div class="canva-embed" data-design-id="DADZnKp0nOE" data-height-ratio="0.5625" style="padding:56.2500% 5px 5px 5px;background:rgba(0,0,0,0.03);border-radius:8px"></div>
<p>When there is a real conflict, vector clocks can help to determine
whether the events were truly concurrent. In the scenario below, two
nodes end up with the events, <code>[0, 1]</code> and <code>[0, 1]</code> which cannot be
ordered. In this situation, the database can keep both values, and
return them the next time it is read, to let either Alice or Bob decide
which one to keep so that the data is not lost.</p>
<div class="canva-embed" data-design-id="DADZnBQkwxE" data-height-ratio="0.5625" style="padding:56.2500% 5px 5px 5px;background:rgba(0,0,0,0.03);border-radius:8px"></div>
<p>These properties, however, do not come for free. The metadata needs to
be exchanged with every message, and multiple versions need to be
stored. After all, some databases, like Cassandra don‚Äôt use vector
clocks <a href="https://www.datastax.com/dev/blog/why-cassandra-doesnt-need-vector-clocks">for a reason</a>.</p>
<h2 id="conclusion"><a class="anchor" href="#conclusion"><span class="icon icon-link"></span></a>Conclusion</h2>
<ul>
<li>
<p>Use <code>System.nanoTime()</code> for measuring time intervals</p>
</li>
<li>
<p>Use <code>System.currentTimeMillis()</code> for obtaining wall-clock time</p>
</li>
<li>
<p>Use <code>Clock.systemUTC().instant()</code> for getting wall-clock time with ns
<em>precision</em></p>
</li>
<li>
<p>Not every clock can give you the resolution you want even if its
precision is high</p>
</li>
<li>
<p>The wall-clock time can be off by dozens of milliseconds (or more, or
less)</p>
</li>
<li>
<p>Use NTP from your cloud provider if time synchronisation matters</p>
</li>
<li>
<p>Logical clocks might be more appropriate than the real clocks but they
have associated costs</p>
</li>
</ul>
<h2 id="thanks"><a class="anchor" href="#thanks"><span class="icon icon-link"></span></a>Thanks</h2>
<ul>
<li>You for reading this article</li>
<li>Uri Baghin for reviewing the article</li>
</ul>
<h2 id="references"><a class="anchor" href="#references"><span class="icon icon-link"></span></a>References</h2>
<ul>
<li><a href="https://shipilev.net/blog/2014/nanotrusting-nanotime/">Nanotrusting the Nanotime</a></li>
<li><a href="https://www.usenix.org/system/files/conference/osdi12/osdi12-final-16.pdf">Spanner: Google‚Äôs Globally-Distributed Database</a></li>
<li><a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/set-time.html">AWSNTP</a> / <a href="https://developers.google.com/time/">Google NTP</a></li>
<li><a href="https://www.youtube.com/watch?v=un1AHZBgFfk">Video PWLSF - Bryan Fink on &quot;A Brief History of NTP Time: Memoirs of an Internet Timekeeper&quot;</a></li>
<li><a href="https://ieeexplore.ieee.org/abstract/document/103043/">Internet time synchronization: the network time protocol</a></li>
<li><a href="https://blog.cloudflare.com/how-and-why-theleap-second-affected-cloudflare-dns/">How and why the leap second affected Cloudflare DNS</a></li>
<li><a href="https://aphyr.com/posts/299-the-trouble-with-timestamps">The trouble with timestamps</a></li>
<li><a href="http://lamport.azurewebsites.net/pubs/time-clocks.pdf">Time, Clocks, and the Ordering of Events in a Distributed System</a></li>
<li><a href="http://zoo.cs.yale.edu/classes/cs426/2012/lab/bib/fidge88timestamps.pdf">Timestamps in Message-Passing Systems That Preserve the Partial Ordering</a></li>
<li><a href="https://blog.rapid7.com/2014/03/14/synchronizing-clocksin-a-cassandra-cluster-pt-1-the-problem/">Synchronizing Clocks In a Cassandra Cluster</a></li>
<li><a href="https://www.datastax.com/dev/blog/why-cassandra-doesnt-need-vector-clocks">Why Cassandra doesn‚Äôt need vector clocks</a></li>
<li><a href="https://www.allthingsdistributed.com/files/amazondynamo-sosp2007.pdf">Dynamo: Amazon‚Äôs Highly Available Key-value Store</a></li>
<li><a href="http://basho.com/posts/technical/why-vector-clocks-are-easy/">Why Vector Clocks Are Easy</a></li>
<li><a href="http://basho.com/posts/technical/why-vector-clocks-are-hard/">Why Vector Clocks Are Hard</a></li>
</ul>
<h2 id="discuss-on"><a class="anchor" href="#discuss-on"><span class="icon icon-link"></span></a>Discuss on</h2>
<ul>
<li><a href="https://twitter.com/SerCeMan/status/1128963307753287680">Twitter</a></li>
<li><a href="https://news.ycombinator.com/item?id=20173673">Hacker News</a></li>
<li><a href="https://www.reddit.com/r/java/comments/bpc0im/the_matter_of_time/">Reddit</a></li>
</ul></div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    h2: \"h2\",\n    a: \"a\",\n    span: \"span\",\n    code: \"code\",\n    pre: \"pre\",\n    h3: \"h3\",\n    em: \"em\",\n    blockquote: \"blockquote\",\n    br: \"br\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components), {Quote, TimeQuizChooser, CheckResults, CanvaEmbed} = _components;\n  if (!CanvaEmbed) _missingMdxReference(\"CanvaEmbed\", true);\n  if (!CheckResults) _missingMdxReference(\"CheckResults\", true);\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  if (!TimeQuizChooser) _missingMdxReference(\"TimeQuizChooser\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Hi!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As software engineers, we all rely on the notion of time: a crucial\\nconcept in ensuring that events in our programs follow a chronological\\norder. Yet, invoking a simple call to ‚Äúget the current time‚Äù can\\npotentially yield unexpected results and lead to unforeseen consequences\\nif not used correctly. Moreover, the invariants about time we observe on\\nour local development machine may not necessarily hold in the cloud, or\\nin any distributed system.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this article, I‚Äôll go through the different ways we can obtain the\\ncurrent time in our programs, and present cases where our intuitions and\\nexpectations of time from these clocks may mislead us at best or cause\\ncatastrophic failures at worst.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/time/time_1.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(Quote, {\n      quote: \"What would be the biological reality of planet earth rotating once every\\neighteen hours instead of twenty-four? You have less time, but you have more days\\nin the year. So there‚Äôs a sense of losing something, and also gaining something.\\nWith an 18-hour clock there‚Äôs a lot more yesterdays.\",\n      attribution: \"Untitled (Clock) 2014\"\n    }), \"\\n\", _jsx(_components.table, {\n      children: _jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"‚ö†Ô∏è\"\n          }), _jsx(_components.th, {\n            children: \"This article is illustrated with examples of code in Java. However, most of the content of this article is applicable to any language or runtime.\"\n          })]\n        })\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"your-local-clocks\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#your-local-clocks\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Your local clocks\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let me start by asking you six questions. Here is a set of code\\nsnippets. Is it possible that the expression passed to \", _jsx(_components.code, {\n        children: \"isThisPossible\"\n      }), \"\\nis true? Take a guess.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      className: \"formalpara-title\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          id: \"aq1\"\n        }), \"1. Is this possible?\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.currentTimeMillis();\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t2\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.currentTimeMillis();\\n\\nisThisPossible(t2 - t1 == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(TimeQuizChooser, {\n      id: \"q1\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          id: \"aq2\"\n        }), \"2. Is this possible?\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.nanoTime();\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t2\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.nanoTime();\\n\\nisThisPossible(t2 - t1 == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(TimeQuizChooser, {\n      id: \"q2\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          id: \"aq3\"\n        }), \"3. Is this possible?\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.currentTimeMillis();\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t2\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.currentTimeMillis();\\n\\nisThisPossible(t2 \u003c t1);\\n\"]\n      })\n    }), \"\\n\", _jsx(TimeQuizChooser, {\n      id: \"q3\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          id: \"aq4\"\n        }), \"4. Is this possible?\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.nanoTime();\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t2\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.nanoTime();\\n\\nisThisPossible(t2 \u003c t1);\\n\"]\n      })\n    }), \"\\n\", _jsx(TimeQuizChooser, {\n      id: \"q4\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          id: \"aq5\"\n        }), \"5. Is this possible?\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.currentTimeMillis();\\n\\nisThisPossible(t1 \u003c \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(TimeQuizChooser, {\n      id: \"q5\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          id: \"aq6\"\n        }), \"6. Is this possible?\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.nanoTime();\\n\\nisThisPossible(t1 \u003c \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(TimeQuizChooser, {\n      id: \"q6\"\n    }), \"\\n\", _jsx(CheckResults, {}), \"\\n\", _jsx(_components.p, {\n      children: \"Was the result surprising? My sincere kudos if it was not. The next\\nsection of the article will explain why certain behaviour can or can not\\nbe observed.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"But why do we even care? Very often we don‚Äôt need to, but the snippets\\nof code where the business logic relies on the observed timestamps are\\ntypically critical pieces of infrastructure code where correctness is a\\nmust. False assumptions in these parts of the code can lead to huge\\nincidents. This, for instance, happened to \", _jsx(_components.a, {\n        href: \"https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/\",\n        children: \"Cloudflare in\\n2017\"\n      }), \",\\nwhere the root cause \\\"was the belief that time cannot go backwards\\\".\\nCloudflare is one of the few companies that openly publishes incident\\nreports, but it‚Äôs not uncommon to suffer from such false assumptions, as\\na few Google searches can confirm, and we can all learn from these\\nmistakes. To understand why certain clocks behave in a certain way, we\\nfirst need to understand what properties different clocks can give us.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"monotonicity\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#monotonicity\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Monotonicity\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The first property is monotonicity. A monotonically increasing function\\nmeans that for every subsequent invocation of such a function the\\nproduced value is never smaller than any of the previous values. So, a\\nmonotonic clock is a clock that never goes backwards. Sadly, and\\nsurprisingly, this property is not a feature of many clocks.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"resolution\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#resolution\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Resolution\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Resolution is the second property. It is the smallest observable\\ndifference between two clock ticks. The resolution of a simple\\nmechanical watch with a second hand is one second. When you‚Äôre staring\\nat the watch, the meaningful watch hand position can be at 12 seconds or\\n13 seconds, but never 12 and a half.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"latency\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#latency\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Latency\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Very often latency is overlooked when we‚Äôre talking about clocks, but\\nit‚Äôs quite important when we‚Äôre considering other properties like\\nresolution. For instance, it doesn‚Äôt matter if you have the most precise\\natomic watch on your hand with picosecond resolution ‚Äí if I ask you what\\ntime it is and it takes you roughly a second, sometimes less, sometimes\\nmore, to take a look and respond, all of this precision fades away.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So, what properties do Java clocks have, and how do they apply to the\\nquestions that we looked at the beginning?\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"clocks-on-the-wall\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#clocks-on-the-wall\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Clocks on the wall\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let‚Äôs start with \", _jsx(_components.code, {\n        children: \"System.currentTimeMillis()\"\n      }), \". Usually, the best place\\nto start the exploration is the documentation written in the Javadoc,\\nand there is a lot there to take in. Here is an excerpt of what is\\nimportant to us right now.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/java.base/share/classes/java/lang/System.java#l375\",\n            children: \"Javadoc\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-comment\",\n          children: [\"/**\\n * Returns the current time in milliseconds. Note that\\n * while the unit of time of the return value is a millisecond,\\n * the granularity of the value depends on the underlying\\n * operating system and may be larger.  For example, many\\n * operating systems measure time in units of tens of\\n * milliseconds.\\n *\\n * ...\\n *\\n * \", _jsx(_components.span, {\n            className: \"hljs-doctag\",\n            children: \"@return\"\n          }), \"  the difference, measured in milliseconds, between\\n *          the current time and midnight, January 1, 1970 UTC.\\n */\"]\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"native\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"currentTimeMillis\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As we can see, the clock provides us with a millisecond precision value\\nbut the actual resolution depends on the operating system. Moreover, if\\nwe measure the latency by measuring the execution time, it will be way\\nbelow 1 millisecond, so it‚Äôs maybe not a surprise that the answer to the\\n\", _jsx(_components.a, {\n        href: \"#aq1\",\n        children: \"first question\"\n      }), \" was yes.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But can it go backwards? The Javadoc doesn‚Äôt mention anything about\\nmonotonicity, so we need to dig deeper, and take a look at the\\nimplementation.\"\n    }), \"\\n\", _jsx(_components.table, {\n      children: _jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"‚ö†Ô∏è\"\n          }), _jsx(_components.th, {\n            children: \"This article only explores the native implementation for Linux and MacOS. However, similar techniques can be applied to other operating systems as well.\"\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The method is native, so the implementation depends on the underlying\\nOS. The native implementation for Linux and MacOS look almost identical.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/linux/os_linux.cpp#l1204\",\n            children: \"Linux\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"jlong \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"os::javaTimeMillis\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" \"]\n        }), \"{\\n  timeval time;\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" status = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"gettimeofday\"\n        }), \"(\u0026time, \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"assert\"\n        }), \"(status != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"-1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"linux error\\\"\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_sec) * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \"  +  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_usec / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \");\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/bsd/os_bsd.cpp#l893\",\n            children: \"MacOS\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"jlong \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"os::javaTimeMillis\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" \"]\n        }), \"{\\n  timeval time;\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" status = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"gettimeofday\"\n        }), \"(\u0026time, \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"assert\"\n        }), \"(status != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"-1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"bsd error\\\"\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_sec) * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \"  +  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_usec / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \");\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The functions invoke exactly the same syscall, \", _jsx(_components.code, {\n        children: \"gettimeofday\"\n      }), \". The man\\npage can provide us with more info, but more importantly with some\\nvaluable notes:\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://man7.org/linux/man-pages/man2/gettimeofday.2.html\",\n            children: \"man page\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"\",\n        children: \"NAME\\n       gettimeofday, settimeofday - get / set time\\n\\nNOTES\\n       The time returned by gettimeofday() is affected by discontinuous\\n       jumps in the system time (e.g., if the system administrator manually\\n       changes the system time).  If you need a monotonically increasing\\n       clock, see clock_gettime(2).\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As noted above, the time is affected by discontinuous jumps in the\\nsystem time, which could be backwards, hence the clock is not monotonic.\\nThe answer to the \", _jsx(_components.a, {\n        href: \"#aq3\",\n        children: \"third question\"\n      }), \" was yes which does make sense:\\nif we change the current time to one hour ago, we still want\\n\", _jsx(_components.code, {\n        children: \"currentTimeMillis\"\n      }), \" to return current time, even though the definition\\nof the current time has changed. That‚Äôs why it‚Äôs often called wall-clock\\ntime, the clock on the wall can also jump back in time if we adjust it.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"the-nanos-of-the-current-time\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#the-nanos-of-the-current-time\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"The nanos of the current time\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The same exploration path can be taken for \", _jsx(_components.code, {\n        children: \"System.nanoTime()\"\n      }), \". Let‚Äôs\\nstart from the Javadoc which has even more intriguing details than the\\nprevious one; here is an excerpt.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/java.base/share/classes/java/lang/System.java#l394\",\n            children: \"Javadoc\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/**\\n * Returns the current value of the running Java Virtual Machine's\\n * high-resolution time source, in nanoseconds.\\n *\\n * This method can only be used to measure elapsed time and is\\n * not related to any other notion of system or wall-clock time.\\n * The value returned represents nanoseconds since some fixed but\\n * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\\n * may be negative) ...\\n *\\n * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\\n * nanosecond resolution ...\\n *\\n * \u003cp\u003eThe values returned by this method become meaningful only when\\n * the difference between two such values, obtained within the same\\n * instance of a Java virtual machine, is computed.\\n *\\n * ...\\n */\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"native\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"nanoTime\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Apparently, the time returned by this clock isn‚Äôt related to any\\nreal-world time; it can only be used to compare the timestamps within\\nthe same JVM instance, and it‚Äôs relative to an arbitrary ‚Äúorigin‚Äù which\\ncan be in the future, and therefore it might be negative ‚Äì which answers\\nthe \", _jsx(_components.a, {\n        href: \"#aq3\",\n        children: \"sixth question\"\n      }), \". Similar to \", _jsx(_components.code, {\n        children: \"currentTimeMillis\"\n      }), \", this method\\nprovides nanosecond precision, but not necessarily nanosecond\\nresolution.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Nano time can only be used to measure time intervals, so it ought to be\\nmonotonic, right? Unfortunately, the Javadoc doesn‚Äôt say anything about\\nmonotonicity, so the next step is the implementation.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/linux/os_linux.cpp#l1301\",\n            children: \"Linux\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"jlong \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"os::javaTimeNanos\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" \"]\n        }), \"{\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (os::\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"supports_monotonic_clock\"\n        }), \"()) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"struct\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"timespec\"\n        }), \" tp;\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" status = Linux::\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"clock_gettime\"\n        }), \"(CLOCK_MONOTONIC, \u0026tp);\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"assert\"\n        }), \"(status == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"gettime error\\\"\"\n        }), \");\\n    jlong result = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(tp.tv_sec) * (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \") + \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(tp.tv_nsec);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" result;\\n  } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n    timeval time;\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" status = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"gettimeofday\"\n        }), \"(\u0026time, \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"assert\"\n        }), \"(status != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"-1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"linux error\\\"\"\n        }), \");\\n    jlong usecs = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_sec) * (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \") + \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_usec);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \" * usecs;\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here comes the first surprise: nano time is indeed monotonic but\\n\", _jsx(_components.em, {\n        children: \"only\"\n      }), \" if the underlying operating system supports it. To be fair, any\\nmodern Linux server supports \", _jsx(_components.code, {\n        children: \"CLOCK_MONOTONIC\"\n      }), \"; there are, however, some\\n\", _jsx(_components.a, {\n        href: \"https://stackoverflow.com/a/51345008/1542319\",\n        children: \"rare situations\"\n      }), \" in which\\nit might not hold true.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/bsd/os_bsd.cpp#l893\",\n            children: \"MacOS\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"jlong \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"os::javaTimeNanos\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" \"]\n        }), \"{\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"uint64_t\"\n        }), \" tm = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"mach_absolute_time\"\n        }), \"();\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"uint64_t\"\n        }), \" now = (tm * Bsd::_timebase_info.numer) / Bsd::_timebase_info.denom;\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"uint64_t\"\n        }), \" prev = Bsd::_max_abstime;\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (now \u003c= prev) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" prev;   \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// same or retrograde time;\"\n        }), \"\\n  }\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"uint64_t\"\n        }), \" obsv = Atomic::\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"cmpxchg\"\n        }), \"(now, \u0026Bsd::_max_abstime, prev);\\n  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"assert\"\n        }), \"(obsv \u003e= prev, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"invariant\\\"\"\n        }), \");   \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Monotonicity\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// If the CAS succeeded then we're done and return \\\"now\\\".\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// If the CAS failed and the observed value \\\"obsv\\\" is \u003e= now then\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// we should return \\\"obsv\\\".  If the CAS failed and now \u003e obsv \u003e prv then\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// some other thread raced this thread and installed a new value, in which case\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// we could either (a) retry the entire operation, (b) retry trying to install now\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// or (c) just return obsv.  We use (c).   No loop is required although in some cases\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// we might discard a higher \\\"now\\\" value in deference to a slightly lower but freshly\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// installed obsv value.   That's entirely benign -- it admits no new orderings compared\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// to (a) or (b) -- and greatly reduces coherence traffic.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// We might also condition (c) on the magnitude of the delta between obsv and now.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Avoiding excessive CAS operations to hot RW locations is critical.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (prev == obsv) ? now : obsv;\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The first thing that stands out is the giant wall of comments. As\\nsoftware engineers, we know that if there is a long comment then\\nsomething dodgy must be going on. Indeed, the comment is quite\\ninteresting. The call to\\n\", _jsx(_components.a, {\n        href: \"https://opensource.apple.com/source/Libc/Libc-320.1.3/i386/mach/mach_absolute_time.c.auto.html\",\n        children: _jsx(_components.code, {\n          children: \"mach_absolute_time\"\n        })\n      }), \"\\nuses the \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Time_Stamp_Counter\",\n        children: \"RDTSC\"\n      }), \"\\ninstruction underneath which can \", _jsx(_components.em, {\n        children: \"potentially\"\n      }), \" lead to non-monotonic\\nbehaviour on machines with multiple CPU sockets, which recently span up\\nanother thought-provoking discussion on the \", _jsx(_components.a, {\n        href: \"https://groups.google.com/forum/#!topic/mechanical-sympathy/7WnH37dA6Yc\",\n        children: \"mechanical\\nsympathy\"\n      }), \"\\nmailing list.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So, at least, we can be confident that nano time is always monotonic on\\nMacOS, right? Actually, it depends on the JVM version. The code listed\\nabove was introduced in JDK9 in\\n\", _jsx(_components.a, {\n        href: \"https://bugs.openjdk.java.net/browse/JDK-8040140\",\n        children: \"JDK-8040140\"\n      }), \" and\\nbackported to JDK8. Before, all you could hope for was non-monotonic\\ntime which provided at best microsecond resolution because\\n\", _jsx(_components.code, {\n        children: \"gettimeofday\"\n      }), \" was used. If we run some\\n\", _jsx(_components.a, {\n        href: \"https://shipilev.net/blog/2014/nanotrusting-nanotime/#_latency\",\n        children: \"benchmarks\"\n      }), \",\\nwe‚Äôll see that the latency for these calls can be as small as 30ns, so\\nsuddenly the answer to the \", _jsx(_components.a, {\n        href: \"#aq2\",\n        children: \"second\"\n      }), \" and the \", _jsx(_components.a, {\n        href: \"#aq4\",\n        children: \"fourth\"\n      }), \"\\nquestions is true, or rather \\\"it depends\\\".\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"when-milliseconds-are-not-enough\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#when-milliseconds-are-not-enough\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"When milliseconds are not enough\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The microsecond precision in the case of \", _jsx(_components.code, {\n        children: \"gettimeofday\"\n      }), \" is much more\\nthan \", _jsx(_components.code, {\n        children: \"System.currentTimeMillis()\"\n      }), \" can give us, but in the process of\\nconversion precision is lost.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"jlong \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"os::javaTimeMillis\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" \"]\n        }), \"{\\n  timeval time;\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" status = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"gettimeofday\"\n        }), \"(\u0026time, \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"assert\"\n        }), \"(status != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"-1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"linux error\\\"\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_sec) * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \"  +  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_usec / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \");\\n                                                      \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ^^ precision loss\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The OS can give us additional information which we violently discard in\\norder to fit it into a single long. What if we really want to know these\\nmicros? In JDK 8, the new JSR 310 arrived which made it possible to\\nobtain an instance of \", _jsx(_components.code, {\n        children: \"Instant\"\n      }), \" class which contains the number of\\nseconds since the epoch and the number of nanoseconds since the last\\nsecond started.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"https://jcp.org/en/jsr/detail?id=310\",\n            children: \"JSR 310: Date and Time API\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Instant\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"instant\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" Clock.systemUTC().instant();\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"epochSecond\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" instant.getEpochSecond();\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"nanoSinceSecond\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" instant.getNano();\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Finally, all Java developers got access to wall-clock time with high\\nprecision, right? Not so fast, if we take a look at the implementation\\nin JDK8, we‚Äôll find out that it simply delegates straight to\\n\", _jsx(_components.code, {\n        children: \"System.currentTimeMillis()\"\n      }), \".\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/time/Clock.java#l469\",\n            children: \"JDK8\\nClock\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"@Override\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"millis\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" System.currentTimeMillis();\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"@Override\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" Instant \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"instant\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" Instant.ofEpochMilli(millis());\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Evidently, this is not optimal and there is a corresponding issue\\n\", _jsx(_components.a, {\n        href: \"https://bugs.openjdk.java.net/browse/JDK-8068730\",\n        children: \"JDK-8068730\"\n      }), \" which\\nhas already been resolved and as a result, the precision was increased.\\nIt requires an update to JDK9+ where the method delegates to a native\\ncall with the following implementation on Linux. Assuming that your OS\\ncan provide microsecond resolution, this clock is a great example of a\\nclock with nanosecond precision, but only microsecond resolution.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/linux/os_linux.cpp#l1211\",\n            children: \"JDK9+\\nClock\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" os::javaTimeSystemUTC(jlong \u0026seconds, jlong \u0026nanos) {\\n  timeval time;\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"status\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" gettimeofday(\u0026time, NULL);\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"assert\"\n        }), \"(status != -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"linux error\\\"\"\n        }), \");\\n  seconds = jlong(time.tv_sec);\\n  nanos = jlong(time.tv_usec) * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"time-exchange\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#time-exchange\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Time exchange\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The possibility to get the current wall-clock time with microsecond\\nresolution is great, but is needed often? One of the reasons to use\\nwall-clock time is to be able to relate an event that happened on one\\nmachine to another event that happened on a different machine, or more\\nprecisely, to decide on the order of these events. The events can be\\nvery different in nature. Some of them might not be very critical, like\\nthe timestamp on a log line, but some of them must be correct, like when\\nthere is a conflict in a database due to two values being written\\nconcurrently and timestamps are used to determine which event was last.\\nThis strategy is called Last Write Wins, or simply LWW.\"\n    }), \"\\n\", _jsx(CanvaEmbed, {\n      designID: \"DADZmyL_mRw\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"On the slides above, two clients Alice and Bob are trying to write\\nsimultaneously into an eventually consistent webscale database with two\\nnodes. While the first value written by Alice was successfully\\nsynchronized, Alice‚Äôs second write happened to be at approximately the\\nsame time as Bob‚Äôs. In this situation, the database must resolve the\\nconflict so that the data is consistent between all of the nodes. In the\\ncase of LWW, the latest write will be chosen by comparing the timestamps\\nof each write. LWW works perfectly if the clocks are perfectly\\nsynchronised, however, if the clocks are poorly synchronised and the\\nclock of the first node has drifted ahead of the second node, LWW\\nbecomes Lucky Write Wins ‚Äì the client connected to the lucky node always\\nwins the conflict.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"ntp\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#ntp\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"NTP\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The standard approach to make sure that the clocks on different nodes in\\nthe cluster are synchronized is to use Network Time Protocol (NTP). Not\\nonly does NTP help synchronise clocks, it also helps propagate a leap\\nsecond flag. Leap second is an occasional event where an additional\\nsecond is introduced in between 23:59:59 of a chosen day and 00:00:00 of\\nthe following day. It‚Äôs often implemented as playing the same second\\ntwice which from the observer‚Äôs point of view might look like a jump 1\\nsecond back in time. The last leap second was introduced on the 31st of\\nDecember 2016 which resulted in the above-mentioned DNS incident.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/time/time_2.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The conventional way of dealing with leap seconds is \\\"leap smearing\\\".\\nThe NTP server which is responsible for leap smearing can distribute the\\nadditional second amongst 12 hours before and 12 hours after the second\\nis introduced. The wall-clock time during these 24 hours is ticking\\nslower and every second is 1/86400 longer which might be surprising,\\nhowever less surprising than a jump back in time. The catch is that not\\nmany NTP servers support leap smearing, the public NTP servers most\\ndefinitely don‚Äôt.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The major cloud providers,\\n\", _jsx(_components.a, {\n        href: \"https://developers.google.com/time/smear\",\n        children: \"Google\"\n      }), \" and\\n\", _jsx(_components.a, {\n        href: \"https://aws.amazon.com/blogs/aws/look-before-you-leap-the-coming-leap-second-and-aws/\",\n        children: \"AWS\"\n      }), \"\\nboth provide NTP services with leap smearing support. If your\\napplication is hosted on a platform that provides an NTP service and you\\ncare about clock synchronisation it‚Äôs worthwhile checking that NTP\\nsynchronisation is set up with the provider‚Äôs NTP service. Not only can\\nit help avoid the nasty consequences of applying leap seconds na√Øvely,\\nbut it also dramatically decreases the synchronisation error since the\\nnetwork latency is typically much lower within a single datacenter.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"AWS NTP with chrony\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-shell\",\n        children: \"sergey:~$ chronyc sources -v\\n210 Number of sources = 9\\n\\n  .-- Source mode  '^' = server, '=' = peer, '#' = local clock.\\n / .- Source state '*' = current synced, '+' = combined , '-' = not combined,\\n| /   '?' = unreachable, 'x' = time may be in error, '~' = time too variable.\\n||                                                 .- xxxx [ yyyy ] +/- zzzz\\n||      Reachability register (octal) -.           |  xxxx = adjusted offset,\\n||      Log2(Polling interval) --.      |          |  yyyy = measured offset,\\n||                                \\\\     |          |  zzzz = estimated error.\\n||                                 |    |           \\\\\\nMS Name/IP address         Stratum Poll Reach LastRx Last sample\\n===============================================================================\\n^* 169.254.169.123               3  10   377   433    -25us[  -36us] +/-  356us\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Using a local NTP server can reduce the clock drift down to milliseconds\\nor even microseconds in the best case, but what is the worst case? There\\nis not much research on this topic, however some notable results were\\nmentioned in the Google Spanner paper.\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Between synchronizations, a daemon advertises a slowly increasing time\\nuncertainty. Œµ is derived from conservatively applied worst-case local\\nclock drift. Œµ also depends on time-master uncertainty and\\ncommunication delay to the time masters. In our production\\nenvironment, Œµ is typically a sawtooth function of time, varying from\\nabout 1 to 7 ms over each poll interval. ŒµÃÖ\\u000f is therefore 4 ms most of\\nthe time. The daemon‚Äôs poll interval is currently 30 seconds, and the\\ncurrent applied drift rate is set at 200 microseconds/second, which\\ntogether accounts for the sawtooth bounds from 0 to 6 ms.\", _jsx(_components.br, {}), \"\\n\", \"‚Äî  Spanner: Google‚Äôs Globally-Distributed Database\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"logical-conclusion\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#logical-conclusion\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Logical conclusion\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Even if the monitoring in our cluster shows that the clocks are\\nsynchronised with microsecond precision, we need to be cautious and\\nshouldn‚Äôt rely on this in our software if a failure of this assumption\\nis unacceptable. So, if a failure is unacceptable and we need to know\\nthe order of the events in a distributed system, is there anything we\\ncan do? As always, there is a number of solutions suggested by academia.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"lamport-clocks\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#lamport-clocks\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Lamport clocks\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"What we need is a reliable replacement for our system clocks, so that\\nfor every two events \", _jsx(_components.em, {\n        children: \"A\"\n      }), \" and \", _jsx(_components.em, {\n        children: \"B\"\n      }), \" we can say that either \", _jsx(_components.em, {\n        children: \"A\"\n      }), \" happened\\nbefore \", _jsx(_components.em, {\n        children: \"B\"\n      }), \", or \", _jsx(_components.em, {\n        children: \"B\"\n      }), \" happened before \", _jsx(_components.em, {\n        children: \"A\"\n      }), \". Such order between events is\\ncalled total order. In the \", _jsx(_components.a, {\n        href: \"https://lamport.azurewebsites.net/pubs/time-clocks.pdf\",\n        children: \"\\\"Time, Clocks, and the Ordering of Events in\\na Distributed\\nSystem\\\"\"\n      }), \" paper\\nLeslie Lamport described the \\\"happens before\\\" relation and logical\\nclocks that can be used to define total order for a set of events using\\nthe following algorithm.\"]\n    }), \"\\n\", _jsxs(\"table\", {\n      children: [_jsxs(\"colgroup\", {\n        children: [_jsx(\"col\", {\n          style: {\n            width: \"50%\"\n          }\n        }), _jsx(\"col\", {\n          style: {\n            width: \"50%\"\n          }\n        })]\n      }), _jsxs(\"tbody\", {\n        children: [_jsxs(\"tr\", {\n          class: \"odd\",\n          children: [_jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"p\", {\n              children: \"Sending a message\"\n            })\n          }), \"\\n\", _jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"p\", {\n              children: \"Receiving a message\"\n            })\n          })]\n        }), _jsxs(\"tr\", {\n          class: \"even\",\n          children: [_jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"pre\", {\n              class: \"pseudocode\",\n              children: _jsx(_components.pre, {\n                children: _jsx(_components.code, {\n                  className: \"\",\n                  children: \"time = time + 1;\\nsend(message, time);\\n\"\n                })\n              })\n            })\n          }), _jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"pre\", {\n              class: \"pseudocode\",\n              children: _jsx(_components.pre, {\n                children: _jsx(_components.code, {\n                  className: \"\",\n                  children: \"(message, ts) = receive();\\ntime = max(ts, time) + 1;\\n\"\n                })\n              })\n            })\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Every actor, in this case, Alice and Bob, will maintain a shared view of\\nthe current time by maintaining a \", _jsx(_components.code, {\n        children: \"time\"\n      }), \" counter which increases every\\ntime a message is sent, and when a message is received, the \", _jsx(_components.code, {\n        children: \"time\"\n      }), \" is\\nalways bigger than the last observed counter. That way if Alice updates\\nthe Database as shown below with the value 2 and tells Bob about the\\nlast known state, Bob‚Äôs final write carries with it the knowledge of\\nseeing Alice‚Äôs counter, so it‚Äôs chosen as the final state of the\\ndatabase.\"]\n    }), \"\\n\", _jsx(_components.table, {\n      children: _jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"‚ùóÔ∏è\"\n          }), _jsx(_components.th, {\n            children: \"In the slides below, Alice tells Bob the value she wrote to the first node. Alternatively, Bob could have read the same value from the first node, leading to the same result ‚Äì Alice and Bob don't have to communicate directly.\"\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(CanvaEmbed, {\n      designID: \"DADZnGWHlAU\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This works perfectly as long as we need to define some total order of\\nthe events in the system which captures the causality. It‚Äôs important to\\nnote that having total order means that concurrent events will be\\nordered in some way, not necessarily the most logical way. On the slides\\nbelow, Alice never talked to Bob, but her counter is bigger which leads\\nto her write being chosen in the case of a conflict.\"\n    }), \"\\n\", _jsx(CanvaEmbed, {\n      designID: \"DADZnC8PNnM\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"vector-clocks\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#vector-clocks\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Vector clocks\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To deal with truly concurrent events, we need a new definition or order\\nwhich is able to express the situation in which events can happen\\nconcurrently. Such order is called partial order. Basically, this means\\nthat for any two events \", _jsx(_components.em, {\n        children: \"A\"\n      }), \" and \", _jsx(_components.em, {\n        children: \"B\"\n      }), \", it‚Äôs possible to say whether \", _jsx(_components.em, {\n        children: \"A\"\n      }), \"\\nhappened before \", _jsx(_components.em, {\n        children: \"B\"\n      }), \", \", _jsx(_components.em, {\n        children: \"B\"\n      }), \" happened before \", _jsx(_components.em, {\n        children: \"A\"\n      }), \" or \", _jsx(_components.em, {\n        children: \"A\"\n      }), \" and \", _jsx(_components.em, {\n        children: \"B\"\n      }), \" happened\\nconcurrently. To determine partial order the following algorithm can be\\nused this, where every actor has a separate time counter, and keeps\\ntrack of the latest timestamp of any other actor in the system.\"]\n    }), \"\\n\", _jsxs(\"table\", {\n      children: [_jsxs(\"colgroup\", {\n        children: [_jsx(\"col\", {\n          style: {\n            width: \"50%\"\n          }\n        }), _jsx(\"col\", {\n          style: {\n            width: \"50%\"\n          }\n        })]\n      }), _jsxs(\"tbody\", {\n        children: [_jsxs(\"tr\", {\n          class: \"odd\",\n          children: [_jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"p\", {\n              children: \"Sending a message\"\n            })\n          }), \"\\n\", _jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"p\", {\n              children: \"Receiving a message\"\n            })\n          })]\n        }), _jsxs(\"tr\", {\n          class: \"even\",\n          children: [_jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"pre\", {\n              class: \"pseudocode\",\n              children: _jsx(_components.pre, {\n                children: _jsx(_components.code, {\n                  className: \"\",\n                  children: \"V[myId] = V[myId] + 1\\nsend(message, V);\\n\"\n                })\n              })\n            })\n          }), _jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"pre\", {\n              class: \"pseudocode\",\n              children: _jsx(_components.pre, {\n                children: _jsx(_components.code, {\n                  className: \"\",\n                  children: \"(message, Vr) = receive();\\nfor (i, v) in Vr {\\n    V[i] = max(V[i], v);\\n}\\nV[myId] = V[myId] + 1;\\n\"\n                })\n              })\n            })\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The algorithm was described in 1988, and later using vector clocks for\\nconflict resolution in a database was described in the Dynamo paper. On\\nthe following slides, Alice keeps track of her own time counter as well\\nas Bob‚Äôs last known time counter. That way when Alice sends a message to\\nBob, he updates his counters and the next message sent to the database\\nis chosen during the conflict resolution because each component of Bob‚Äôs\\ntime vector is larger than the respective component of the previous\\nvector.\"\n    }), \"\\n\", _jsx(CanvaEmbed, {\n      designID: \"DADZnKp0nOE\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When there is a real conflict, vector clocks can help to determine\\nwhether the events were truly concurrent. In the scenario below, two\\nnodes end up with the events, \", _jsx(_components.code, {\n        children: \"[0, 1]\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"[0, 1]\"\n      }), \" which cannot be\\nordered. In this situation, the database can keep both values, and\\nreturn them the next time it is read, to let either Alice or Bob decide\\nwhich one to keep so that the data is not lost.\"]\n    }), \"\\n\", _jsx(CanvaEmbed, {\n      designID: \"DADZnBQkwxE\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"These properties, however, do not come for free. The metadata needs to\\nbe exchanged with every message, and multiple versions need to be\\nstored. After all, some databases, like Cassandra don‚Äôt use vector\\nclocks \", _jsx(_components.a, {\n        href: \"https://www.datastax.com/dev/blog/why-cassandra-doesnt-need-vector-clocks\",\n        children: \"for a reason\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"conclusion\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#conclusion\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Conclusion\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"System.nanoTime()\"\n          }), \" for measuring time intervals\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"System.currentTimeMillis()\"\n          }), \" for obtaining wall-clock time\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"Clock.systemUTC().instant()\"\n          }), \" for getting wall-clock time with ns\\n\", _jsx(_components.em, {\n            children: \"precision\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Not every clock can give you the resolution you want even if its\\nprecision is high\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"The wall-clock time can be off by dozens of milliseconds (or more, or\\nless)\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Use NTP from your cloud provider if time synchronisation matters\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Logical clocks might be more appropriate than the real clocks but they\\nhave associated costs\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"thanks\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#thanks\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Thanks\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"You for reading this article\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Uri Baghin for reviewing the article\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"references\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#references\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"References\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://shipilev.net/blog/2014/nanotrusting-nanotime/\",\n          children: \"Nanotrusting the Nanotime\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.usenix.org/system/files/conference/osdi12/osdi12-final-16.pdf\",\n          children: \"Spanner: Google‚Äôs Globally-Distributed Database\"\n        })\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/set-time.html\",\n          children: \"AWSNTP\"\n        }), \" / \", _jsx(_components.a, {\n          href: \"https://developers.google.com/time/\",\n          children: \"Google NTP\"\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.youtube.com/watch?v=un1AHZBgFfk\",\n          children: \"Video PWLSF - Bryan Fink on \\\"A Brief History of NTP Time: Memoirs of an Internet Timekeeper\\\"\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://ieeexplore.ieee.org/abstract/document/103043/\",\n          children: \"Internet time synchronization: the network time protocol\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://blog.cloudflare.com/how-and-why-theleap-second-affected-cloudflare-dns/\",\n          children: \"How and why the leap second affected Cloudflare DNS\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://aphyr.com/posts/299-the-trouble-with-timestamps\",\n          children: \"The trouble with timestamps\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://lamport.azurewebsites.net/pubs/time-clocks.pdf\",\n          children: \"Time, Clocks, and the Ordering of Events in a Distributed System\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://zoo.cs.yale.edu/classes/cs426/2012/lab/bib/fidge88timestamps.pdf\",\n          children: \"Timestamps in Message-Passing Systems That Preserve the Partial Ordering\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://blog.rapid7.com/2014/03/14/synchronizing-clocksin-a-cassandra-cluster-pt-1-the-problem/\",\n          children: \"Synchronizing Clocks In a Cassandra Cluster\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.datastax.com/dev/blog/why-cassandra-doesnt-need-vector-clocks\",\n          children: \"Why Cassandra doesn‚Äôt need vector clocks\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.allthingsdistributed.com/files/amazondynamo-sosp2007.pdf\",\n          children: \"Dynamo: Amazon‚Äôs Highly Available Key-value Store\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://basho.com/posts/technical/why-vector-clocks-are-easy/\",\n          children: \"Why Vector Clocks Are Easy\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://basho.com/posts/technical/why-vector-clocks-are-hard/\",\n          children: \"Why Vector Clocks Are Hard\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"discuss-on\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#discuss-on\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Discuss on\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://twitter.com/SerCeMan/status/1128963307753287680\",\n          children: \"Twitter\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://news.ycombinator.com/item?id=20173673\",\n          children: \"Hacker News\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.reddit.com/r/java/comments/bpc0im/the_matter_of_time/\",\n          children: \"Reddit\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"The matter of time()","description":"Empty","date":"2019-05-16"}},"frontMatter":{"title":"The matter of time()","description":"Empty","date":"2019-05-16"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"16-05-2019-the-matter-of-time"},"buildId":"mbWVr8AwAz6q39oslIoEa","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>